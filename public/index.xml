<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Recent Content on  </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/engine/index.xml/</link>
    
    
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>engine-index</title>
      <link>http://localhost:1313/engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/engine/</guid>
      <description>

&lt;p&gt;Engine is a core package to drive a Go web framework. Routing, context, statuses
and more close the distance between the Go standard library and your own web
framework.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;Install&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;go get github.com/thrisp/engine
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Quickstart&lt;/h3&gt;

&lt;p&gt;main.go&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;os&amp;quot;
    &amp;quot;os/signal&amp;quot;
    &amp;quot;github.com/thrisp/engine&amp;quot;
)

func Display(c *engine.Ctx) {
    c.RW.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/html&amp;quot;)
    c.RW.Write(&amp;quot;HELLO WORLD!&amp;quot;)
}

var quit = make(chan bool)

func init() {
    c := make(chan os.Signal, 1)
    signal.Notify(c, os.Interrupt)
    go func() {
        for _ = range c {
            quit &amp;lt;- true
        }
    }()
}

func main() {
    e := engine.Basic()
    e.Manage(&amp;quot;GET&amp;quot;, &amp;quot;/hello/world/&amp;quot;, Display)
    go e.Run(&amp;quot;:8080&amp;quot;)
    &amp;lt;-quit
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;go run main.go&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://localhost:1313/engine/docs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      
      <guid>http://localhost:1313/engine/docs/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;engine&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;import &amp;quot;github.com/thrisp/engine&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Constants&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    ErrorTypeInternal = 1 &amp;lt;&amp;lt; iota
    ErrorTypeExternal = 1 &amp;lt;&amp;lt; iota
    ErrorTypePanic    = 1 &amp;lt;&amp;lt; iota
    ErrorTypeAll      = 0xffffffff
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    NotWritten = -1
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;func CleanPath&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func CleanPath(p string) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CleanPath is the URL version of path.Clean, it returns a canonical URL path
for p, eliminating . and .. elements.&lt;/p&gt;

&lt;p&gt;The following rules are applied iteratively until no further processing can
be done:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. Replace multiple slashes with a single slash.
2. Eliminate each . path name element (the current directory).
3. Eliminate each inner .. path name element (the parent directory)
   along with the non-.. element that precedes it.
4. Eliminate .. elements that begin a rooted path:
   that is, replace &amp;quot;/..&amp;quot; by &amp;quot;/&amp;quot; at the beginning of a path.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the result of this process is an empty string, &amp;ldquo;/&amp;rdquo; is returned&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;func PanicHandle&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func PanicHandle(c *Ctx)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PanicHandler is called with Http status 500 that gets all ErrorTypePanic from
*Ctx.Errors, logs to logger if LoggingOn is true(general logging otherwise,
you need to be informed of panics), and and serves a basic html page if engine
ServePanic is true.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;type Ctx&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Ctx struct {
    RW      ResponseWriter
    Request *http.Request
    Params  Params
    Form    url.Values
    // Files
    Errors errorMsgs
    // contains filtered or unexported fields
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;func (*Ctx) Abort&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Ctx) Abort(code int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Immediately abort the context writing out the code to the response&lt;/p&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;func (*Ctx) Error&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Ctx) Error(err error, meta interface{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Attaches an error that is pushed to a list of errors. It&amp;rsquo;s a good idea
to call Error for each error that occurred during the resolution of a request.
A middleware can be used to collect all the errors and push them to a database
together, print a log, or append it in the HTTP response.&lt;/p&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;func (*Ctx) Fail&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Ctx) Fail(code int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fail is the same as Abort plus an error message.
Calling &lt;code&gt;c.Fail(500, err)&lt;/code&gt; is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c.Error(err, &amp;quot;Failed.&amp;quot;)
c.Abort(500)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;func (*Ctx) LastError&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Ctx) LastError() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Returns the last error for the Ctx.&lt;/p&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;func (*Ctx) Status&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Ctx) Status(code int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Calls an HttpException in the current group by integer code from the Context,
if the status exists.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;type Engine&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Engine struct {
    *Group
    // contains filtered or unexported fields
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Engine is the the core struct containing Groups, sync.Pool cache, and
signaling, in addition to configuration options.&lt;/p&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;func Basic&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Basic() *Engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basic produces a new engine with LoggingOn set to true&lt;/p&gt;

&lt;h3 id=&#34;toc_12&#34;&gt;func Empty&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Empty() *Engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Empty returns an empty Engine with zero configuration.&lt;/p&gt;

&lt;h3 id=&#34;toc_13&#34;&gt;func New&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func New() *Engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New produces a new engine, with default configuration, method for retrieving
a new Ctx, signals &amp;amp; logging.&lt;/p&gt;

&lt;h3 id=&#34;toc_14&#34;&gt;func (*Engine) Handler&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *Engine) Handler(method, path string, handler http.Handler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Handler allows the usage of a http.Handler as request manage.&lt;/p&gt;

&lt;h3 id=&#34;toc_15&#34;&gt;func (*Engine) HandlerFunc&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *Engine) HandlerFunc(method, path string, handler http.HandlerFunc)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HandlerFunc allows the use of a http.HandlerFunc as request manage.&lt;/p&gt;

&lt;h3 id=&#34;toc_16&#34;&gt;func (*Engine) LogSignal&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *Engine) LogSignal()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_17&#34;&gt;func (*Engine) Lookup&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *Engine) Lookup(method, path string) (Manage, Params, bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lookup allows the manual lookup of a method + path combo.&lt;/p&gt;

&lt;h3 id=&#34;toc_18&#34;&gt;func (*Engine) Manage&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *Engine) Manage(method string, path string, m Manage)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;manage registers a new request Manage function with the given path and method.&lt;/p&gt;

&lt;h3 id=&#34;toc_19&#34;&gt;func (*Engine) NewSignaller&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *Engine) NewSignaller() signal
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_20&#34;&gt;func (*Engine) Run&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (engine *Engine) Run(addr string)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_21&#34;&gt;func (*Engine) SendSignal&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *Engine) SendSignal(msg string)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_22&#34;&gt;func (*Engine) ServeFiles&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *Engine) ServeFiles(path string, root http.FileSystem)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ServeFiles serves files from the given file system root.
The path must end with &amp;ldquo;/*filepath&amp;rdquo;, files are then served from the local
path /defined/root/dir/*filepath.
For example if root is &amp;ldquo;/etc&amp;rdquo; and *filepath is &amp;ldquo;passwd&amp;rdquo;, the local file
&amp;ldquo;/etc/passwd&amp;rdquo; would be served.
Internally a http.FileServer is used, therefore http.NotFound is used instead
of the Router&amp;rsquo;s NotFound handler.
To use the operating system&amp;rsquo;s file system implementation,
use http.Dir:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.ServeFiles(&amp;quot;/src/*filepath&amp;quot;, http.Dir(&amp;quot;/var/www&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_23&#34;&gt;func (*Engine) ServeHTTP&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ServeHTTP makes the engine implement the http.Handler interface.&lt;/p&gt;

&lt;h2 id=&#34;toc_24&#34;&gt;type EngineError&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type EngineError struct {
    // contains filtered or unexported fields
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_25&#34;&gt;func (*EngineError) Error&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (e *EngineError) Error() string
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_26&#34;&gt;type Group&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Group struct {
    HttpStatuses
    // contains filtered or unexported fields
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_27&#34;&gt;func NewGroup&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewGroup(prefix string, engine *Engine) *Group
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NewGroup creates a group with no parent and the provided prefix, usually as
a primary engine Group&lt;/p&gt;

&lt;h3 id=&#34;toc_28&#34;&gt;func (*Group) Handle&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (group *Group) Handle(route string, method string, handler Manage)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Handle provides a route, method, and Manage to the router, and creates
a function using the handler when the router matches the route and method.&lt;/p&gt;

&lt;h3 id=&#34;toc_29&#34;&gt;func (*Group) New&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (group *Group) New(component string) *Group
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New creates a group from an existing group using the component string as a
prefix for all subsequent route attachments to the group. The existing group
will be the parent of the new group, and both will share the same engine&lt;/p&gt;

&lt;h2 id=&#34;toc_30&#34;&gt;type HttpStatus&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type HttpStatus struct {
    // contains filtered or unexported fields
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Status code, message, and handlers for a http status.&lt;/p&gt;

&lt;h3 id=&#34;toc_31&#34;&gt;func NewHttpStatus&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewHttpStatus(code int, message string) *HttpStatus
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_32&#34;&gt;func (*HttpStatus) Update&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (h *HttpStatus) Update(handlers ...Manage)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adds any number of custom Manage to the HttpStatus, between the
default status before &amp;amp; after handlers.&lt;/p&gt;

&lt;h2 id=&#34;toc_33&#34;&gt;type HttpStatuses&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type HttpStatuses map[int]*HttpStatus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A map of HttpStatus instances, keyed by status code&lt;/p&gt;

&lt;h3 id=&#34;toc_34&#34;&gt;func (HttpStatuses) New&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (hs HttpStatuses) New(h *HttpStatus)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New creates a HttpStatus in the HttpStatuss map.&lt;/p&gt;

&lt;h2 id=&#34;toc_35&#34;&gt;type Manage&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Manage func(*Ctx)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Manage is a function that can be registered to a route to handle HTTP
requests. Like http.HandlerFunc, but takes a *Ctx&lt;/p&gt;

&lt;h2 id=&#34;toc_36&#34;&gt;type Param&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Param struct {
    Key   string
    Value string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Param is a single URL parameter, consisting of a key and a value.&lt;/p&gt;

&lt;h2 id=&#34;toc_37&#34;&gt;type Params&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Params []Param
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Params is a Param-slice, as returned by the router. The slice is ordered,
the first URL parameter is also the first slice value. It is safe to read
values by the index.&lt;/p&gt;

&lt;h3 id=&#34;toc_38&#34;&gt;func (Params) ByName&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (ps Params) ByName(name string) string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ByName returns the value of the first Param which key matches the given name.
If no matching Param is found, an empty string is returned.&lt;/p&gt;

&lt;h2 id=&#34;toc_39&#34;&gt;type ResponseWriter&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ResponseWriter interface {
    http.ResponseWriter
    http.Hijacker
    http.Flusher
    http.CloseNotifier

    Status() int
    Size() int
    Written() bool
    WriteHeaderNow()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Generated by &lt;a href=&#34;http://godoc.org/github.com/davecheney/godoc2md&#34;&gt;godoc2md&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>