<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Documentation </title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <link rel="stylesheet" href="/engine/css/poole.css">
    <link rel="stylesheet" href="/engine/css/syntax.css">
    <link rel="stylesheet" href="/engine/css/engine.css">
    <link href='https://fonts.googleapis.com/css?family=PT+Sans' rel='stylesheet' type='text/css'>
    
    
</head>

<html>
    <body>
        <div class="sidebar">
    <div class="container">
        <div class="sidebar-about">
            <h1>Engine</h1>
            <img src="/engine/img/engine-logo-1.png"></img>
        </div>
        <div class="sidebar-sticky">
            <ul class="sidebar-nav">
                <li><a href="/engine">The Engine Website</a></li>
                <li><a href="http://github.com/thrisp/engine">Engine @ github</a></li>
                <li><a href="http://github.com/thrisp/engine/issues">Issue Tracker</a></li>
            </ul>
            <h6><p>Â© Copyright 2014 <a href="http://github.com/thrisp">thrisp/hurrata</a></p></h6>
        </div>  
    </div>
</div>

        <div class="content container">
            

<h1 id="toc_0">engine</h1>

<pre><code>import &quot;github.com/thrisp/engine&quot;
</code></pre>

<h2 id="toc_1">Constants</h2>

<pre><code class="language-go">const (
    ErrorTypeInternal = 1 &lt;&lt; iota
    ErrorTypeExternal = 1 &lt;&lt; iota
    ErrorTypePanic    = 1 &lt;&lt; iota
    ErrorTypeAll      = 0xffffffff
)
</code></pre>

<pre><code class="language-go">const (
    NotWritten = -1
)
</code></pre>

<h2 id="toc_2">func CleanPath</h2>

<pre><code class="language-go">func CleanPath(p string) string
</code></pre>

<p>CleanPath is the URL version of path.Clean, it returns a canonical URL path
for p, eliminating . and .. elements.</p>

<p>The following rules are applied iteratively until no further processing can
be done:</p>

<pre><code>1. Replace multiple slashes with a single slash.
2. Eliminate each . path name element (the current directory).
3. Eliminate each inner .. path name element (the parent directory)
   along with the non-.. element that precedes it.
4. Eliminate .. elements that begin a rooted path:
   that is, replace &quot;/..&quot; by &quot;/&quot; at the beginning of a path.
</code></pre>

<p>If the result of this process is an empty string, &ldquo;/&rdquo; is returned</p>

<h2 id="toc_3">func PanicHandle</h2>

<pre><code class="language-go">func PanicHandle(c *Ctx)
</code></pre>

<p>PanicHandle is the default Manage for 500 &amp; internal panics. Retrieves all
ErrorTypePanic from *Ctx.Errors, sends signal, logs to stdout or logger, and
serves a basic html page if engine.ServePanic is true.</p>

<h2 id="toc_4">type Ctx</h2>

<pre><code class="language-go">type Ctx struct {
    RW      ResponseWriter
    Request *http.Request
    Params  Params
    Form    url.Values
    // Files tbd
    Errors errorMsgs
    // contains filtered or unexported fields
}
</code></pre>

<p>Ctx is the core request-response context passed between any Manage
handlers, useful for storing &amp; persisting data within a request &amp; response.</p>

<h3 id="toc_5">func (*Ctx) Abort</h3>

<pre><code class="language-go">func (c *Ctx) Abort(code int)
</code></pre>

<p>Immediately abort the context, writing out the code to the response</p>

<h3 id="toc_6">func (*Ctx) Error</h3>

<pre><code class="language-go">func (c *Ctx) Error(err error, meta interface{})
</code></pre>

<p>Attaches an error to a list of errors. Call Error for each error that occurred
during the resolution of a request.</p>

<h3 id="toc_7">func (*Ctx) Fail</h3>

<pre><code class="language-go">func (c *Ctx) Fail(code int, err error)
</code></pre>

<p>Fail is the same as Abort plus an error message.
Calling <code>c.Fail(500, err)</code> is equivalent to:</p>

<pre><code>c.Error(err, &quot;Failed.&quot;)
c.Abort(500)
</code></pre>

<h3 id="toc_8">func (*Ctx) LastError</h3>

<pre><code class="language-go">func (c *Ctx) LastError() error
</code></pre>

<p>Returns the last error for the Ctx.</p>

<h3 id="toc_9">func (*Ctx) Status</h3>

<pre><code class="language-go">func (c *Ctx) Status(code int)
</code></pre>

<p>Calls an HttpStatus in the current group by integer code from the Context,
if the status exists.</p>

<h2 id="toc_10">type Engine</h2>

<pre><code class="language-go">type Engine struct {
    *Group
    // contains filtered or unexported fields
}
</code></pre>

<p>Engine is the the core struct containing Groups, sync.Pool cache, and
signaling, in addition to configuration options.</p>

<h3 id="toc_11">func Basic</h3>

<pre><code class="language-go">func Basic() *Engine
</code></pre>

<p>Basic produces a new engine with LoggingOn set to true and visible logging.</p>

<h3 id="toc_12">func Empty</h3>

<pre><code class="language-go">func Empty() *Engine
</code></pre>

<p>Empty returns an empty Engine with zero configuration.</p>

<h3 id="toc_13">func New</h3>

<pre><code class="language-go">func New() *Engine
</code></pre>

<p>New produces a new engine, with default configuration, a base group, method
for retrieving a new Ctx, and signalling.</p>

<h3 id="toc_14">func (*Engine) Handler</h3>

<pre><code class="language-go">func (e *Engine) Handler(method, path string, handler http.Handler)
</code></pre>

<p>Handler allows the usage of a http.Handler as request manage.</p>

<h3 id="toc_15">func (*Engine) HandlerFunc</h3>

<pre><code class="language-go">func (e *Engine) HandlerFunc(method, path string, handler http.HandlerFunc)
</code></pre>

<p>HandlerFunc allows the use of a http.HandlerFunc as request manage.</p>

<h3 id="toc_16">func (*Engine) LogSignal</h3>

<pre><code class="language-go">func (e *Engine) LogSignal()
</code></pre>

<h3 id="toc_17">func (*Engine) Lookup</h3>

<pre><code class="language-go">func (e *Engine) Lookup(method, path string) (Manage, Params, bool)
</code></pre>

<p>Lookup allows the manual lookup of a method + path combo.</p>

<h3 id="toc_18">func (*Engine) Manage</h3>

<pre><code class="language-go">func (e *Engine) Manage(method string, path string, m Manage)
</code></pre>

<p>Registers a new request Manage function with the given path and method.</p>

<h3 id="toc_19">func (*Engine) NewSignaller</h3>

<pre><code class="language-go">func (e *Engine) NewSignaller() signal
</code></pre>

<h3 id="toc_20">func (*Engine) Run</h3>

<pre><code class="language-go">func (engine *Engine) Run(addr string)
</code></pre>

<h3 id="toc_21">func (*Engine) SendSignal</h3>

<pre><code class="language-go">func (e *Engine) SendSignal(msg string)
</code></pre>

<h3 id="toc_22">func (*Engine) ServeFiles</h3>

<pre><code class="language-go">func (e *Engine) ServeFiles(path string, root http.FileSystem)
</code></pre>

<p>ServeFiles serves files from the given file system root. The path must end
with &ldquo;/*filepath&rdquo;, files are then served from the local path
/defined/root/dir/*filepath.</p>

<p>e.g., if root is &ldquo;/etc&rdquo; and *filepath is &ldquo;passwd&rdquo;, the local file
&ldquo;/etc/passwd&rdquo; would be served.</p>

<p>Internally a http.FileServer is used, therefore http.NotFound is used instead
of the Router&rsquo;s NotFound handler.</p>

<p>To use the operating system&rsquo;s file system implementation,
use http.Dir:</p>

<pre><code>router.ServeFiles(&quot;/src/\*filepath&quot;, http.Dir(&quot;/var/www&quot;))
</code></pre>

<h3 id="toc_23">func (*Engine) ServeHTTP</h3>

<pre><code class="language-go">func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request)
</code></pre>

<p>ServeHTTP makes the engine implement the http.Handler interface.</p>

<h2 id="toc_24">type EngineError</h2>

<pre><code class="language-go">type EngineError struct {
    // contains filtered or unexported fields
}
</code></pre>

<h3 id="toc_25">func (*EngineError) Error</h3>

<pre><code class="language-go">func (e *EngineError) Error() string
</code></pre>

<h2 id="toc_26">type Group</h2>

<pre><code class="language-go">type Group struct {
    HttpStatuses
    // contains filtered or unexported fields
}
</code></pre>

<h3 id="toc_27">func NewGroup</h3>

<pre><code class="language-go">func NewGroup(prefix string, engine *Engine) *Group
</code></pre>

<p>NewGroup creates a group with no parent and the provided prefix, usually as
a primary engine Group</p>

<h3 id="toc_28">func (*Group) Handle</h3>

<pre><code class="language-go">func (group *Group) Handle(route string, method string, handler Manage)
</code></pre>

<p>Handle provides a route, method, and Manage to the router, and creates
a function using the handler when the router matches the route and method.</p>

<h3 id="toc_29">func (*Group) New</h3>

<pre><code class="language-go">func (group *Group) New(component string) *Group
</code></pre>

<p>New creates a group from an existing group using the component string as a
prefix for all subsequent route attachments to the group. The existing group
will be the parent of the new group, and both will share the same engine</p>

<h2 id="toc_30">type HttpStatus</h2>

<pre><code class="language-go">type HttpStatus struct {
    Code     int
    Message  string
    Handlers []Manage
}
</code></pre>

<p>Status code, message, and Manage handlers for a http status.</p>

<h3 id="toc_31">func NewHttpStatus</h3>

<pre><code class="language-go">func NewHttpStatus(code int, message string) *HttpStatus
</code></pre>

<p>Create new HttpStatus with the code, message, and default Manage handlers.</p>

<h3 id="toc_32">func (*HttpStatus) Update</h3>

<pre><code class="language-go">func (h *HttpStatus) Update(handlers ...Manage)
</code></pre>

<p>Adds any number of custom Manage to the HttpStatus, between the
default status before &amp; after manage.</p>

<h2 id="toc_33">type HttpStatuses</h2>

<pre><code class="language-go">type HttpStatuses map[int]*HttpStatus
</code></pre>

<p>A map of HttpStatus instances, keyed by status code</p>

<h3 id="toc_34">func (HttpStatuses) New</h3>

<pre><code class="language-go">func (hs HttpStatuses) New(h *HttpStatus)
</code></pre>

<p>New adds a new HttpStatus to HttpStatuses keyed by status code.</p>

<h2 id="toc_35">type Manage</h2>

<pre><code class="language-go">type Manage func(*Ctx)
</code></pre>

<p>Manage is a function that can be registered to a route to handle HTTP
requests. Like http.HandlerFunc, but takes a *Ctx</p>

<h2 id="toc_36">type Param</h2>

<pre><code class="language-go">type Param struct {
    Key   string
    Value string
}
</code></pre>

<p>Param is a single URL parameter, consisting of a key and a value.</p>

<h2 id="toc_37">type Params</h2>

<pre><code class="language-go">type Params []Param
</code></pre>

<p>Params is a Param-slice, as returned by the router. The slice is ordered,
the first URL parameter is also the first slice value. It is safe to read
values by the index.</p>

<h3 id="toc_38">func (Params) ByName</h3>

<pre><code class="language-go">func (ps Params) ByName(name string) string
</code></pre>

<p>ByName returns the value of the first Param which key matches the given name.
If no matching Param is found, an empty string is returned.</p>

<h2 id="toc_39">type ResponseWriter</h2>

<pre><code class="language-go">type ResponseWriter interface {
    http.ResponseWriter
    http.Hijacker
    http.Flusher
    http.CloseNotifier

    Status() int
    Size() int
    Written() bool
    WriteHeaderNow()
}
</code></pre>

        </div>
    </body>
</html>
